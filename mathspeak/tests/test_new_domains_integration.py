#!/usr/bin/env python3
"""
Integration Tests for All New Domain Processors
==============================================

This module tests the integration of all newly implemented domain processors:
- Real Analysis
- Measure Theory  
- Combinatorics
- Algorithms

Tests include:
- Cross-domain expressions
- Context switching
- Performance with mixed content
- Compatibility with existing system
- Edge cases and stress tests
"""

import pytest
import logging
import time
from typing import List, Dict, Any

# Import all domain processors
from domains.real_analysis import RealAnalysisProcessor
from domains.measure_theory import MeasureTheoryProcessor
from domains.combinatorics import CombinatoricsProcessor
from domains.algorithms import AlgorithmsProcessor

# Import existing processors for integration testing
from domains.topology import TopologyProcessor
from domains.complex_analysis import ComplexAnalysisProcessor

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class TestDomainIntegration:
    """Test integration between all domain processors"""
    
    @pytest.fixture
    def processors(self):
        """Create instances of all processors"""
        return {
            'real_analysis': RealAnalysisProcessor(),
            'measure_theory': MeasureTheoryProcessor(),
            'combinatorics': CombinatoricsProcessor(),
            'algorithms': AlgorithmsProcessor(),
            'topology': TopologyProcessor(),
            'complex_analysis': ComplexAnalysisProcessor(),
        }
    
    # ===== CROSS-DOMAIN EXPRESSIONS =====
    
    def test_real_analysis_with_measure_theory(self, processors):
        """Test expressions combining real analysis and measure theory"""
        test_cases = [
            # Lebesgue integration in real analysis
            (
                r"f \in L^1(\mathbb{R}, \lambda) \Rightarrow \int_{\mathbb{R}} |f| d\lambda < \infty",
                ['real_analysis', 'measure_theory'],
                ["L 1 space", "lambda", "integral", "less than infinity"]
            ),
            # Convergence theorems
            (
                r"If f_n \to f \text{ a.e. and } |f_n| \leq g \in L^1, then \lim_{n \to \infty} \int f_n d\mu = \int f d\mu",
                ['real_analysis', 'measure_theory'],
                ["converges to f almost everywhere", "limit as n approaches infinity", "integral"]
            ),
        ]
        
        for latex, domains, expected_parts in test_cases:
            results = {}
            for domain in domains:
                results[domain] = processors[domain].process(latex)
            
            # Check that both processors handle it reasonably
            for domain, result in results.items():
                for part in expected_parts:
                    assert part in result.lower(), \
                        f"Missing '{part}' in {domain} result: {result}"
    
    def test_combinatorics_with_algorithms(self, processors):
        """Test expressions combining combinatorics and algorithms"""
        test_cases = [
            # Graph algorithms complexity
            (
                r"DFS on a graph G = (V,E) runs in O(|V| + |E|) time",
                ['combinatorics', 'algorithms'],
                ["graph", "vertex", "edge", "big O"]
            ),
            # Counting in algorithms
            (
                r"There are \binom{n}{k} ways to choose k elements, computed in O(nk) time",
                ['combinatorics', 'algorithms'],
                ["n choose k", "big O of"]
            ),
            # Dynamic programming for combinatorics
            (
                r"dp[n][k] = \binom{n}{k} can be computed using Pascal's triangle",
                ['combinatorics', 'algorithms'],
                ["DP", "n choose k", "pascal"]
            ),
        ]
        
        for latex, domains, expected_parts in test_cases:
            results = {}
            for domain in domains:
                results[domain] = processors[domain].process(latex)
            
            for domain, result in results.items():
                logger.info(f"{domain} result: {result}")
                # Each processor should handle at least some parts
                matches = sum(1 for part in expected_parts if part in result.lower())
                assert matches >= len(expected_parts) // 2, \
                    f"{domain} didn't handle enough parts of mixed expression"
    
    def test_topology_with_measure_theory(self, processors):
        """Test integration between existing topology and new measure theory"""
        test_cases = [
            # Borel sets in topology
            (
                r"The Borel \sigma-algebra \mathcal{B}(X) is generated by the topology \tau",
                ['topology', 'measure_theory'],
                ["borel", "sigma-algebra", "topology"]
            ),
            # Measure on topological spaces
            (
                r"A Radon measure on a topological space (X, \tau) is regular",
                ['topology', 'measure_theory'],
                ["radon measure", "topological space", "regular"]
            ),
        ]
        
        for latex, domains, expected_parts in test_cases:
            results = {}
            for domain in domains:
                results[domain] = processors[domain].process(latex)
            
            for part in expected_parts:
                found = any(part in result.lower() for result in results.values())
                assert found, f"'{part}' not found in any processor output"
    
    # ===== MIXED MATHEMATICAL DOCUMENTS =====
    
    def test_mixed_document_processing(self, processors):
        """Test processing a document with mixed mathematical content"""
        document = [
            # Real analysis
            r"Consider the function $f: \mathbb{R} \to \mathbb{R}$ with $f'(x) = 2x$.",
            # Measure theory
            r"Let $\mu$ be a finite measure on $(\mathbb{R}, \mathcal{B}(\mathbb{R}))$.",
            # Combinatorics
            r"The number of subsets of size $k$ from $n$ elements is $\binom{n}{k}$.",
            # Algorithms
            r"This can be computed in $O(n)$ time using dynamic programming.",
            # Complex expression
            r"If $\sum_{n=1}^\infty |a_n| < \infty$, then $\sum_{n=1}^\infty a_n$ converges.",
        ]
        
        # Process with each relevant processor
        for sentence in document:
            processed = False
            for name, processor in processors.items():
                try:
                    result = processor.process(sentence)
                    if result and len(result) > len(sentence) * 0.5:
                        processed = True
                        logger.info(f"{name} processed: {sentence[:30]}...")
                        break
                except Exception as e:
                    logger.warning(f"{name} failed on: {sentence[:30]}... - {e}")
            
            assert processed, f"No processor handled: {sentence}"
    
    # ===== PERFORMANCE TESTS =====
    
    def test_performance_all_domains(self, processors):
        """Test performance across all domains"""
        expressions = {
            'real_analysis': [
                r"\lim_{x \to 0} \frac{\sin x}{x} = 1",
                r"\int_0^1 x^2 dx = \frac{1}{3}",
                r"f'(x) = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h}",
            ],
            'measure_theory': [
                r"\mu(A \cup B) \leq \mu(A) + \mu(B)",
                r"\int f d\mu = \int f^+ d\mu - \int f^- d\mu",
                r"L^p(X, \mu) \text{ is a Banach space}",
            ],
            'combinatorics': [
                r"\binom{n}{k} = \frac{n!}{k!(n-k)!}",
                r"F_n = F_{n-1} + F_{n-2}",
                r"\chi(K_n) = n",
            ],
            'algorithms': [
                r"T(n) = 2T(n/2) + O(n)",
                r"\text{quicksort runs in } O(n \log n) \text{ average time}",
                r"dp[i][j] = \min(dp[i-1][j], dp[i][j-1]) + cost[i][j]",
            ],
        }
        
        total_expressions = 0
        start_time = time.time()
        
        for domain, expr_list in expressions.items():
            processor = processors[domain]
            for expr in expr_list * 10:  # Process each 10 times
                _ = processor.process(expr)
                total_expressions += 1
        
        end_time = time.time()
        total_time = end_time - start_time
        avg_time = total_time / total_expressions
        
        logger.info(f"Processed {total_expressions} expressions in {total_time:.2f}s")
        logger.info(f"Average time per expression: {avg_time*1000:.2f}ms")
        
        # Should maintain good performance even with all domains
        assert avg_time < 0.02, f"Processing too slow: {avg_time:.4f}s per expression"
    
    # ===== EDGE CASES =====
    
    def test_empty_and_invalid_input(self, processors):
        """Test all processors handle empty/invalid input gracefully"""
        test_cases = [
            "",
            " ",
            "\n",
            "plain text with no math",
            r"\invalid{command}",
            r"$",  # Unclosed math
            None,
        ]
        
        for test_input in test_cases:
            if test_input is None:
                continue
            
            for name, processor in processors.items():
                try:
                    result = processor.process(test_input)
                    assert isinstance(result, str), f"{name} didn't return string"
                except Exception as e:
                    pytest.fail(f"{name} crashed on edge case '{test_input}': {e}")
    
    def test_very_long_expressions(self, processors):
        """Test processors handle very long expressions"""
        # Generate a very long expression
        long_expr = r"\sum_{i=1}^{1000} " + " + ".join([f"a_{{{i}}}" for i in range(50)])
        
        for name, processor in processors.items():
            if name in ['real_analysis', 'measure_theory', 'algorithms']:
                try:
                    start = time.time()
                    result = processor.process(long_expr)
                    duration = time.time() - start
                    
                    assert isinstance(result, str)
                    assert duration < 1.0, f"{name} took too long: {duration:.2f}s"
                except Exception as e:
                    pytest.fail(f"{name} failed on long expression: {e}")
    
    # ===== SPECIAL CHARACTERS =====
    
    def test_unicode_handling(self, processors):
        """Test processors handle Unicode mathematical symbols"""
        test_cases = [
            r"α + β = γ",  # Greek letters
            r"∀x ∈ ℝ",     # Unicode math symbols
            r"∫₀¹ f(x) dx", # Unicode subscripts
            r"x → ∞",       # Unicode arrows
        ]
        
        for expr in test_cases:
            handled = False
            for name, processor in processors.items():
                try:
                    result = processor.process(expr)
                    if result != expr:  # Processor did something
                        handled = True
                        break
                except:
                    pass
            
            # At least one processor should handle it
            assert handled, f"No processor handled Unicode: {expr}"
    
    # ===== CONTEXT SWITCHING =====
    
    def test_context_preservation(self, processors):
        """Test that processors maintain context correctly"""
        # Process multiple expressions and check context
        real_analysis_exprs = [
            r"\lim_{x \to 0} f(x)",
            r"\int_0^1 f(x) dx",
            r"f'(x) = 0",
        ]
        
        processor = processors['real_analysis']
        contexts = []
        
        for expr in real_analysis_exprs:
            _ = processor.process(expr)
            contexts.append(processor.context)
        
        # Should detect appropriate contexts
        assert any(ctx.value == 'limits' for ctx in contexts)
        assert any(ctx.value == 'integration' for ctx in contexts)
        assert any(ctx.value == 'differentiation' for ctx in contexts)
    
    # ===== COMPATIBILITY TESTS =====
    
    def test_output_format_compatibility(self, processors):
        """Test that output format is compatible with TTS requirements"""
        test_expr = r"\sum_{n=1}^\infty \frac{1}{n^2} = \frac{\pi^2}{6}"
        
        for name, processor in processors.items():
            result = processor.process(test_expr)
            
            # Check for TTS compatibility
            assert not any(c in result for c in "<>&"), \
                f"{name} output contains XML/HTML characters"
            
            # Should be mostly ASCII (some Greek letters allowed)
            non_ascii = [c for c in result if ord(c) > 127]
            assert len(non_ascii) < 10, \
                f"{name} has too many non-ASCII characters: {non_ascii}"
            
            # Should not be too long
            assert len(result) < 1000, \
                f"{name} output too long: {len(result)} chars"


class TestComplexMathematicalDocuments:
    """Test processing of complex mathematical documents"""
    
    def test_theorem_proof_structure(self):
        """Test processing theorem and proof structures"""
        processors = {
            'real_analysis': RealAnalysisProcessor(),
            'measure_theory': MeasureTheoryProcessor(),
        }
        
        theorem = """
        Theorem (Dominated Convergence): Let $(f_n)$ be a sequence of measurable functions
        such that $f_n \to f$ a.e. and $|f_n| \leq g$ for some $g \in L^1(\mu)$.
        Then $\lim_{n \to \infty} \int f_n d\mu = \int f d\mu$.
        """
        
        # Both processors should handle this
        for name, processor in processors.items():
            result = processor.process(theorem)
            assert "dominated convergence" in result.lower()
            assert "measurable functions" in result.lower()
            assert "almost everywhere" in result.lower()
    
    def test_multi_line_equation(self):
        """Test processing multi-line equations"""
        processor = AlgorithmsProcessor()
        
        equation = r"""
        T(n) = \begin{cases}
            O(1) & \text{if } n = 1 \\
            2T(n/2) + O(n) & \text{if } n > 1
        \end{cases}
        """
        
        result = processor.process(equation)
        assert "big O of 1" in result.lower()
        assert "big O of n" in result.lower()
    
    def test_mixed_notation_styles(self):
        """Test handling of mixed notation styles"""
        processor = CombinatoricsProcessor()
        
        mixed = r"The binomial coefficient $\binom{n}{k} = C(n,k) = {}_nC_k = \frac{n!}{k!(n-k)!}$"
        result = processor.process(mixed)
        
        assert "n choose k" in result.lower()
        assert "n factorial" in result.lower()


class TestErrorRecovery:
    """Test error recovery and robustness"""
    
    def test_partial_latex_commands(self):
        """Test handling of partial/broken LaTeX commands"""
        processors = [
            RealAnalysisProcessor(),
            MeasureTheoryProcessor(),
            CombinatoricsProcessor(),
            AlgorithmsProcessor(),
        ]
        
        broken_commands = [
            r"\lim_{x \to",     # Incomplete limit
            r"\int_0^",         # Incomplete integral
            r"\binom{n",        # Incomplete binomial
            r"O(n^",            # Incomplete complexity
        ]
        
        for processor in processors:
            for cmd in broken_commands:
                try:
                    result = processor.process(cmd)
                    assert isinstance(result, str)
                except Exception as e:
                    pytest.fail(f"{processor.__class__.__name__} crashed on '{cmd}': {e}")
    
    def test_nested_commands(self):
        """Test deeply nested mathematical expressions"""
        processor = RealAnalysisProcessor()
        
        nested = r"\lim_{n \to \infty} \left( \int_0^1 \left( \sum_{k=1}^n \frac{x^k}{k!} \right) dx \right)"
        result = processor.process(nested)
        
        assert "limit as n approaches infinity" in result.lower()
        assert "integral from 0 to 1" in result.lower()
        assert "sum from k equals 1 to n" in result.lower()


# ===== STRESS TESTS =====

class TestStressScenarios:
    """Stress test the processors with extreme cases"""
    
    def test_rapid_context_switching(self):
        """Test rapid switching between different mathematical contexts"""
        expressions = [
            (r"\lim_{x \to 0} f(x)", RealAnalysisProcessor()),
            (r"\mu(A \cup B)", MeasureTheoryProcessor()),
            (r"\binom{n}{k}", CombinatoricsProcessor()),
            (r"O(n \log n)", AlgorithmsProcessor()),
        ] * 25  # 100 expressions with context switches
        
        start_time = time.time()
        for expr, processor in expressions:
            _ = processor.process(expr)
        duration = time.time() - start_time
        
        assert duration < 2.0, f"Context switching too slow: {duration:.2f}s"
    
    def test_memory_usage(self):
        """Test memory usage doesn't grow excessively"""
        import psutil
        import os
        
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        # Process many expressions
        processor = RealAnalysisProcessor()
        for i in range(1000):
            expr = f"\\lim_{{x \\to {i}}} f_{{{i}}}(x) = {i}"
            _ = processor.process(expr)
        
        final_memory = process.memory_info().rss / 1024 / 1024  # MB
        memory_growth = final_memory - initial_memory
        
        assert memory_growth < 100, f"Memory grew by {memory_growth:.1f}MB"


if __name__ == "__main__":
    # Run tests
    pytest.main([__file__, "-v", "--tb=short"])